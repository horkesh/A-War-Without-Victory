<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>AWWV — Polygon Region Editor</title>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
body {
  font-family: 'Segoe UI', system-ui, sans-serif;
  background: #111;
  color: #ccc;
  display: flex;
  height: 100vh;
  overflow: hidden;
}

/* ── Sidebar ── */
#sidebar {
  width: 340px;
  min-width: 340px;
  background: #1a1a2e;
  border-right: 1px solid #333;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}
#sidebar-header {
  padding: 12px 16px;
  border-bottom: 1px solid #333;
  font-size: 13px;
  font-weight: 700;
  letter-spacing: 1px;
  text-transform: uppercase;
  color: #8899aa;
}
#sidebar-header span { color: #e0e6ef; }

#load-section {
  padding: 12px 16px;
  border-bottom: 1px solid #333;
  display: flex;
  flex-direction: column;
  gap: 8px;
}
#load-section label {
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 1px;
  color: #6a7a8e;
}
#load-section input[type="file"] { font-size: 12px; color: #ccc; }
#image-info { font-size: 11px; color: #6a7a8e; }

#region-list-container {
  flex: 1;
  overflow-y: auto;
  padding: 8px 0;
}
.region-item {
  padding: 8px 16px;
  border-bottom: 1px solid #222;
  cursor: pointer;
  font-size: 12px;
  display: flex;
  align-items: center;
  gap: 8px;
  transition: background 0.1s;
}
.region-item:hover { background: rgba(255,255,255,0.04); }
.region-item.selected { background: rgba(70,130,180,0.2); border-left: 3px solid #4a90d9; }
.region-item .color-swatch {
  width: 12px; height: 12px; border-radius: 2px; flex-shrink: 0;
  border: 1px solid rgba(255,255,255,0.2);
}
.region-item .region-id { flex: 1; font-family: 'Courier New', monospace; color: #e0e6ef; }
.region-item .region-info { color: #6a7a8e; font-size: 10px; }
.region-item .delete-btn {
  background: none; border: none; color: #664; cursor: pointer; font-size: 14px;
  padding: 2px 4px; border-radius: 3px;
}
.region-item .delete-btn:hover { color: #f44; background: rgba(255,0,0,0.1); }

#props-panel {
  border-top: 1px solid #333;
  padding: 12px 16px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  max-height: 360px;
  overflow-y: auto;
}
#props-panel.hidden { display: none; }
#props-panel label {
  font-size: 10px; text-transform: uppercase; letter-spacing: 1px; color: #6a7a8e;
  margin-bottom: 2px;
}
#props-panel input, #props-panel select {
  background: #111; border: 1px solid #333; border-radius: 3px;
  color: #e0e6ef; padding: 5px 8px; font-size: 12px; font-family: 'Courier New', monospace;
  width: 100%;
}
#props-panel select { cursor: pointer; }
.prop-row { display: flex; gap: 6px; }
.prop-row > div { flex: 1; display: flex; flex-direction: column; }
.prop-row input { width: 100%; }
.prop-checkbox { display: flex; align-items: center; gap: 6px; }
.prop-checkbox input[type="checkbox"] { width: auto; }
.prop-info {
  font-size: 10px; color: #556; font-family: 'Courier New', monospace;
  padding: 4px 0;
}

#actions {
  padding: 12px 16px;
  border-top: 1px solid #333;
  display: flex;
  flex-direction: column;
  gap: 6px;
}
.btn {
  padding: 8px 12px;
  border: 1px solid #333;
  border-radius: 4px;
  background: rgba(255,255,255,0.05);
  color: #c0cad8;
  font-size: 11px;
  font-weight: 600;
  letter-spacing: 1px;
  text-transform: uppercase;
  cursor: pointer;
  text-align: center;
  transition: background 0.15s, border-color 0.15s;
}
.btn:hover { background: rgba(255,255,255,0.1); border-color: #555; }
.btn-primary { border-color: #4a90d9; color: #7ab8f5; }
.btn-primary:hover { background: rgba(74,144,217,0.15); }
.btn-danger { border-color: #944; color: #f66; }
.btn-danger:hover { background: rgba(255,50,50,0.1); }
.btn-row { display: flex; gap: 6px; }
.btn-row .btn { flex: 1; }

/* ── Canvas area ── */
#canvas-area {
  flex: 1;
  position: relative;
  overflow: auto;
  background: #0a0a0a;
  display: flex;
  align-items: center;
  justify-content: center;
}
#canvas-wrapper {
  position: relative;
  display: inline-block;
}
#bg-canvas, #overlay-canvas { display: block; }
#overlay-canvas {
  position: absolute;
  top: 0; left: 0;
  cursor: crosshair;
}

#zoom-controls {
  position: absolute;
  top: 10px; right: 10px;
  display: flex; gap: 4px; z-index: 10;
}
#zoom-controls .btn { padding: 6px 10px; font-size: 13px; }
#zoom-label {
  padding: 6px 10px; font-size: 11px; color: #6a7a8e;
  background: rgba(0,0,0,0.6); border-radius: 4px;
}

#coords {
  position: absolute;
  bottom: 10px; left: 10px;
  font-family: 'Courier New', monospace; font-size: 12px; color: #6a7a8e;
  background: rgba(0,0,0,0.7); padding: 4px 10px; border-radius: 4px; z-index: 10;
}

#mode-indicator {
  position: absolute;
  bottom: 10px; right: 10px;
  font-family: 'Courier New', monospace; font-size: 11px;
  padding: 4px 10px; border-radius: 4px; z-index: 10;
  background: rgba(0,0,0,0.7);
}
#mode-indicator.drawing { color: #4ad97a; }
#mode-indicator.editing { color: #d9b44a; }

#instructions {
  position: absolute;
  top: 10px; left: 10px;
  font-size: 11px; color: #556;
  background: rgba(0,0,0,0.7);
  padding: 8px 12px; border-radius: 4px;
  line-height: 1.6; z-index: 10; max-width: 320px;
}
#instructions kbd {
  background: #222; border: 1px solid #444; border-radius: 2px;
  padding: 1px 4px; font-size: 10px;
}
</style>
</head>
<body>

<div id="sidebar">
  <div id="sidebar-header"><span>AWWV</span> Polygon Region Editor</div>

  <div id="load-section">
    <label>Background image</label>
    <input type="file" id="file-input" accept="image/*">
    <div id="image-info">No image loaded</div>
    <label>Import existing JSON</label>
    <input type="file" id="json-input" accept=".json">
  </div>

  <div id="region-list-container"></div>

  <div id="props-panel" class="hidden">
    <label>ID</label>
    <input type="text" id="prop-id" placeholder="e.g. faction_flag">
    <label>Type</label>
    <select id="prop-type">
      <option value="sprite_overlay">sprite_overlay</option>
      <option value="dynamic_render">dynamic_render</option>
      <option value="baked_prop">baked_prop</option>
    </select>
    <label>Bounds (auto-computed from polygon)</label>
    <div class="prop-row">
      <div><label>X</label><input type="number" id="prop-x" min="0" readonly></div>
      <div><label>Y</label><input type="number" id="prop-y" min="0" readonly></div>
      <div><label>W</label><input type="number" id="prop-w" min="1" readonly></div>
      <div><label>H</label><input type="number" id="prop-h" min="1" readonly></div>
    </div>
    <div class="prop-info" id="prop-vertex-count"></div>
    <label>Action</label>
    <input type="text" id="prop-action" placeholder="e.g. open_faction_overview">
    <label>Hover style</label>
    <select id="prop-hover">
      <option value="glow">glow</option>
      <option value="red_outline">red_outline</option>
      <option value="none">none</option>
    </select>
    <label>Cursor</label>
    <select id="prop-cursor">
      <option value="pointer">pointer</option>
      <option value="default">default</option>
    </select>
    <label>Tooltip</label>
    <input type="text" id="prop-tooltip" placeholder="e.g. Faction Overview">
    <label>Layer</label>
    <select id="prop-layer">
      <option value="wall">wall</option>
      <option value="desk">desk</option>
    </select>
    <div class="prop-checkbox">
      <input type="checkbox" id="prop-disabled">
      <label for="prop-disabled" style="margin:0;text-transform:none;font-size:12px;color:#ccc;">Disabled</label>
    </div>
  </div>

  <div id="actions">
    <div class="btn-row">
      <button class="btn btn-primary" id="btn-export">Export JSON</button>
      <button class="btn" id="btn-copy">Copy JSON</button>
    </div>
    <button class="btn btn-danger" id="btn-clear-all">Clear All Regions</button>
  </div>
</div>

<div id="canvas-area">
  <div id="instructions">
    <strong>Polygon Drawing:</strong><br>
    Click to place vertices<br>
    Double-click or click near first point to close<br>
    <kbd>Enter</kbd> to close polygon<br>
    <kbd>Esc</kbd> to cancel / deselect<br>
    <kbd>Ctrl+Z</kbd> undo last point<br>
    <strong>Editing:</strong><br>
    Click polygon to select, drag vertices to move<br>
    Right-click vertex to delete it<br>
    Click on edge to insert vertex<br>
    <kbd>Delete</kbd> to remove selected polygon<br>
    Scroll to zoom
  </div>
  <div id="zoom-controls">
    <button class="btn" id="btn-zoom-in">+</button>
    <button class="btn" id="btn-zoom-out">-</button>
    <button class="btn" id="btn-zoom-fit">Fit</button>
    <span id="zoom-label">100%</span>
  </div>
  <div id="coords">---, ---</div>
  <div id="mode-indicator" class="drawing">DRAW MODE</div>
  <div id="canvas-wrapper">
    <canvas id="bg-canvas"></canvas>
    <canvas id="overlay-canvas"></canvas>
  </div>
</div>

<script>
// ── State ──
let regions = [];       // Each: { id, type, polygon:[[x,y],...], action, hover_style, cursor, tooltip, layer, disabled, color }
let selectedIdx = -1;
let bgImage = null;
let imgW = 2048, imgH = 1152;
let zoom = 1;

// Drawing state
let drawingPoints = [];   // Points being placed for new polygon
let mousePos = null;      // Current mouse position in image coords

// Editing state
let dragVertexIdx = -1;   // Index of vertex being dragged in selected polygon
let dragging = false;

// Undo stack
let undoStack = [];       // Each entry: { type, data }

const COLORS = [
  '#4a90d9', '#d94a4a', '#4ad97a', '#d9b44a', '#9b4ad9',
  '#4ad9d9', '#d94a90', '#90d94a', '#d96a4a', '#4a6ad9'
];
const VERTEX_RADIUS = 6;
const CLOSE_THRESHOLD = 15; // pixels in image space to snap to first vertex
const EDGE_INSERT_THRESHOLD = 8;

// ── DOM refs ──
const bgCanvas = document.getElementById('bg-canvas');
const bgCtx = bgCanvas.getContext('2d');
const overlay = document.getElementById('overlay-canvas');
const ctx = overlay.getContext('2d');
const canvasArea = document.getElementById('canvas-area');
const canvasWrapper = document.getElementById('canvas-wrapper');
const fileInput = document.getElementById('file-input');
const jsonInput = document.getElementById('json-input');
const imageInfo = document.getElementById('image-info');
const regionList = document.getElementById('region-list-container');
const propsPanel = document.getElementById('props-panel');
const coordsEl = document.getElementById('coords');
const zoomLabel = document.getElementById('zoom-label');
const modeIndicator = document.getElementById('mode-indicator');

const propId = document.getElementById('prop-id');
const propType = document.getElementById('prop-type');
const propX = document.getElementById('prop-x');
const propY = document.getElementById('prop-y');
const propW = document.getElementById('prop-w');
const propH = document.getElementById('prop-h');
const propVertexCount = document.getElementById('prop-vertex-count');
const propAction = document.getElementById('prop-action');
const propHover = document.getElementById('prop-hover');
const propCursor = document.getElementById('prop-cursor');
const propTooltip = document.getElementById('prop-tooltip');
const propLayer = document.getElementById('prop-layer');
const propDisabled = document.getElementById('prop-disabled');

// ── Helpers ──
function hexAlpha(hex, alpha) {
  const r = parseInt(hex.slice(1,3), 16);
  const g = parseInt(hex.slice(3,5), 16);
  const b = parseInt(hex.slice(5,7), 16);
  return `rgba(${r},${g},${b},${alpha})`;
}

function dist(a, b) {
  return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
}

function distPt(ax, ay, bx, by) {
  return Math.sqrt((ax - bx) ** 2 + (ay - by) ** 2);
}

function computeBounds(polygon) {
  if (!polygon || polygon.length === 0) return { x: 0, y: 0, width: 0, height: 0 };
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  for (const [x, y] of polygon) {
    if (x < minX) minX = x;
    if (y < minY) minY = y;
    if (x > maxX) maxX = x;
    if (y > maxY) maxY = y;
  }
  return { x: Math.round(minX), y: Math.round(minY), width: Math.round(maxX - minX), height: Math.round(maxY - minY) };
}

function pointInPolygon(px, py, polygon) {
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const [xi, yi] = polygon[i];
    const [xj, yj] = polygon[j];
    if (((yi > py) !== (yj > py)) && (px < (xj - xi) * (py - yi) / (yj - yi) + xi)) {
      inside = !inside;
    }
  }
  return inside;
}

function distToSegment(px, py, ax, ay, bx, by) {
  const dx = bx - ax, dy = by - ay;
  const lenSq = dx * dx + dy * dy;
  if (lenSq === 0) return distPt(px, py, ax, ay);
  let t = ((px - ax) * dx + (py - ay) * dy) / lenSq;
  t = Math.max(0, Math.min(1, t));
  return distPt(px, py, ax + t * dx, ay + t * dy);
}

function toImageCoords(e) {
  const rect = overlay.getBoundingClientRect();
  const x = Math.round((e.clientX - rect.left) / zoom);
  const y = Math.round((e.clientY - rect.top) / zoom);
  return { x: Math.max(0, Math.min(imgW, x)), y: Math.max(0, Math.min(imgH, y)) };
}

function isDrawing() { return drawingPoints.length > 0; }

function updateModeIndicator() {
  if (isDrawing()) {
    modeIndicator.textContent = `DRAWING — ${drawingPoints.length} pts`;
    modeIndicator.className = 'drawing';
  } else if (selectedIdx >= 0) {
    modeIndicator.textContent = 'EDIT MODE';
    modeIndicator.className = 'editing';
  } else {
    modeIndicator.textContent = 'DRAW MODE';
    modeIndicator.className = 'drawing';
  }
}

// ── Image loading ──
fileInput.addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const img = new Image();
  img.onload = () => {
    bgImage = img;
    imgW = img.naturalWidth;
    imgH = img.naturalHeight;
    imageInfo.textContent = `${imgW} x ${imgH} — ${file.name}`;
    resizeCanvases();
    drawBg();
    redraw();
  };
  img.src = URL.createObjectURL(file);
});

// ── JSON import ──
jsonInput.addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    try {
      const data = JSON.parse(ev.target.result);
      if (data.image_dimensions) {
        imgW = data.image_dimensions.width || imgW;
        imgH = data.image_dimensions.height || imgH;
      }
      if (Array.isArray(data.regions)) {
        regions = data.regions.map((r, i) => {
          // Support both v1 (rect only) and v2 (polygon)
          let polygon = r.polygon;
          if (!polygon && r.bounds) {
            // Convert rect bounds to polygon
            const b = r.bounds;
            polygon = [[b.x, b.y], [b.x + b.width, b.y], [b.x + b.width, b.y + b.height], [b.x, b.y + b.height]];
          }
          return {
            id: r.id || `region_${i}`,
            type: r.type || 'baked_prop',
            polygon: polygon || [],
            action: r.action || '',
            hover_style: r.hover_style || 'glow',
            cursor: r.cursor || 'pointer',
            tooltip: r.tooltip || '',
            layer: r.layer || 'desk',
            disabled: r.disabled || false,
            color: COLORS[i % COLORS.length]
          };
        });
        selectedIdx = -1;
        drawingPoints = [];
        renderRegionList();
        resizeCanvases();
        drawBg();
        redraw();
      }
    } catch (err) {
      alert('Invalid JSON: ' + err.message);
    }
  };
  reader.readAsText(file);
});

// ── Canvas sizing ──
function resizeCanvases() {
  bgCanvas.width = imgW;
  bgCanvas.height = imgH;
  overlay.width = imgW;
  overlay.height = imgH;
  applyZoom();
}

function applyZoom() {
  const w = Math.round(imgW * zoom);
  const h = Math.round(imgH * zoom);
  canvasWrapper.style.width = w + 'px';
  canvasWrapper.style.height = h + 'px';
  bgCanvas.style.width = w + 'px';
  bgCanvas.style.height = h + 'px';
  overlay.style.width = w + 'px';
  overlay.style.height = h + 'px';
  zoomLabel.textContent = Math.round(zoom * 100) + '%';
}

function fitZoom() {
  const areaW = canvasArea.clientWidth - 40;
  const areaH = canvasArea.clientHeight - 40;
  zoom = Math.min(areaW / imgW, areaH / imgH, 1);
  applyZoom();
}

// ── Background drawing ──
function drawBg() {
  bgCtx.clearRect(0, 0, imgW, imgH);
  if (bgImage) {
    bgCtx.drawImage(bgImage, 0, 0, imgW, imgH);
  } else {
    bgCtx.fillStyle = '#1a1a1a';
    bgCtx.fillRect(0, 0, imgW, imgH);
    bgCtx.strokeStyle = '#282828';
    bgCtx.lineWidth = 1;
    for (let x = 0; x < imgW; x += 100) {
      bgCtx.beginPath(); bgCtx.moveTo(x, 0); bgCtx.lineTo(x, imgH); bgCtx.stroke();
    }
    for (let y = 0; y < imgH; y += 100) {
      bgCtx.beginPath(); bgCtx.moveTo(0, y); bgCtx.lineTo(imgW, y); bgCtx.stroke();
    }
    bgCtx.fillStyle = '#333';
    bgCtx.font = '14px monospace';
    bgCtx.fillText(`${imgW} x ${imgH} — load an image`, 20, 30);
  }
}

// ── Overlay drawing ──
function redraw() {
  ctx.clearRect(0, 0, imgW, imgH);

  // Draw all regions
  for (let i = 0; i < regions.length; i++) {
    const r = regions[i];
    const poly = r.polygon;
    if (!poly || poly.length < 3) continue;
    const isSelected = i === selectedIdx;
    const color = r.color || COLORS[i % COLORS.length];

    // Fill
    ctx.beginPath();
    ctx.moveTo(poly[0][0], poly[0][1]);
    for (let j = 1; j < poly.length; j++) ctx.lineTo(poly[j][0], poly[j][1]);
    ctx.closePath();
    ctx.fillStyle = isSelected ? hexAlpha(color, 0.3) : hexAlpha(color, 0.15);
    ctx.fill();

    // Stroke
    ctx.strokeStyle = isSelected ? color : hexAlpha(color, 0.6);
    ctx.lineWidth = isSelected ? 2.5 : 1.5;
    if (!isSelected) { ctx.setLineDash([6, 3]); }
    ctx.stroke();
    ctx.setLineDash([]);

    // Label at centroid
    const cx = poly.reduce((s, p) => s + p[0], 0) / poly.length;
    const cy = poly.reduce((s, p) => s + p[1], 0) / poly.length;
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 13px "Courier New", monospace';
    ctx.shadowColor = 'rgba(0,0,0,0.8)';
    ctx.shadowBlur = 4;
    ctx.textAlign = 'center';
    ctx.fillText(r.id, cx, cy + 5);
    ctx.shadowBlur = 0;
    ctx.textAlign = 'left';

    // Vertex handles for selected
    if (isSelected) {
      for (let j = 0; j < poly.length; j++) {
        ctx.beginPath();
        ctx.arc(poly[j][0], poly[j][1], VERTEX_RADIUS, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1.5;
        ctx.stroke();
      }
    }
  }

  // Draw in-progress polygon
  if (drawingPoints.length > 0) {
    ctx.beginPath();
    ctx.moveTo(drawingPoints[0][0], drawingPoints[0][1]);
    for (let i = 1; i < drawingPoints.length; i++) {
      ctx.lineTo(drawingPoints[i][0], drawingPoints[i][1]);
    }
    // Line to mouse
    if (mousePos) {
      ctx.lineTo(mousePos.x, mousePos.y);
    }
    ctx.strokeStyle = 'rgba(255,255,255,0.8)';
    ctx.lineWidth = 2;
    ctx.setLineDash([4, 4]);
    ctx.stroke();
    ctx.setLineDash([]);

    // Closing line preview (first point to mouse)
    if (mousePos && drawingPoints.length >= 2) {
      ctx.beginPath();
      ctx.moveTo(drawingPoints[0][0], drawingPoints[0][1]);
      ctx.lineTo(mousePos.x, mousePos.y);
      ctx.strokeStyle = 'rgba(255,255,255,0.2)';
      ctx.lineWidth = 1;
      ctx.setLineDash([2, 4]);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // Vertices
    for (let i = 0; i < drawingPoints.length; i++) {
      ctx.beginPath();
      ctx.arc(drawingPoints[i][0], drawingPoints[i][1], VERTEX_RADIUS, 0, Math.PI * 2);
      ctx.fillStyle = i === 0 ? '#4ad97a' : '#fff';
      ctx.fill();
      ctx.strokeStyle = i === 0 ? '#fff' : '#888';
      ctx.lineWidth = 1.5;
      ctx.stroke();
    }

    // Snap indicator near first point
    if (mousePos && drawingPoints.length >= 3) {
      const d = distPt(mousePos.x, mousePos.y, drawingPoints[0][0], drawingPoints[0][1]);
      if (d < CLOSE_THRESHOLD) {
        ctx.beginPath();
        ctx.arc(drawingPoints[0][0], drawingPoints[0][1], CLOSE_THRESHOLD, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(74,217,122,0.5)';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }
  }

  updateModeIndicator();
}

// ── Mouse interaction ──
overlay.addEventListener('mousedown', (e) => {
  if (e.button === 2) {
    // Right-click: delete vertex if editing
    e.preventDefault();
    if (selectedIdx >= 0) {
      const p = toImageCoords(e);
      const poly = regions[selectedIdx].polygon;
      for (let i = 0; i < poly.length; i++) {
        if (distPt(p.x, p.y, poly[i][0], poly[i][1]) < VERTEX_RADIUS * 2) {
          if (poly.length <= 3) return; // can't have fewer than 3
          undoStack.push({ type: 'delete_vertex', regionIdx: selectedIdx, vertexIdx: i, point: [...poly[i]] });
          poly.splice(i, 1);
          redraw();
          updatePropsFromRegion();
          return;
        }
      }
    }
    return;
  }
  if (e.button !== 0) return;

  const p = toImageCoords(e);

  // If drawing, don't do edit interactions
  if (isDrawing()) return;

  // Check if clicking a vertex of selected polygon
  if (selectedIdx >= 0) {
    const poly = regions[selectedIdx].polygon;
    for (let i = 0; i < poly.length; i++) {
      if (distPt(p.x, p.y, poly[i][0], poly[i][1]) < VERTEX_RADIUS * 2) {
        dragVertexIdx = i;
        dragging = true;
        undoStack.push({ type: 'move_vertex', regionIdx: selectedIdx, vertexIdx: i, oldPoint: [...poly[i]] });
        return;
      }
    }

    // Check if clicking on an edge of selected polygon — insert vertex
    for (let i = 0; i < poly.length; i++) {
      const j = (i + 1) % poly.length;
      const d = distToSegment(p.x, p.y, poly[i][0], poly[i][1], poly[j][0], poly[j][1]);
      if (d < EDGE_INSERT_THRESHOLD) {
        undoStack.push({ type: 'insert_vertex', regionIdx: selectedIdx, vertexIdx: j, point: [p.x, p.y] });
        poly.splice(j, 0, [p.x, p.y]);
        dragVertexIdx = j;
        dragging = true;
        redraw();
        updatePropsFromRegion();
        return;
      }
    }
  }

  // Check if clicking inside any polygon
  for (let i = regions.length - 1; i >= 0; i--) {
    const poly = regions[i].polygon;
    if (poly && poly.length >= 3 && pointInPolygon(p.x, p.y, poly)) {
      selectRegion(i);
      return;
    }
  }

  // Not inside any polygon — deselect
  if (selectedIdx >= 0) {
    selectRegion(-1);
  }
});

overlay.addEventListener('click', (e) => {
  if (e.button !== 0) return;
  if (dragging) return; // was a drag, not a click

  const p = toImageCoords(e);

  // If we just selected/deselected or were editing, don't start drawing
  // Only enter drawing mode if nothing was interacted with
  if (selectedIdx >= 0) return;

  // Drawing mode: add point
  // Check if close to first point → close polygon
  if (drawingPoints.length >= 3) {
    const d = distPt(p.x, p.y, drawingPoints[0][0], drawingPoints[0][1]);
    if (d < CLOSE_THRESHOLD) {
      finishPolygon();
      return;
    }
  }

  drawingPoints.push([p.x, p.y]);
  undoStack.push({ type: 'add_point' });
  redraw();
});

overlay.addEventListener('dblclick', (e) => {
  e.preventDefault();
  if (drawingPoints.length >= 3) {
    // Remove the last point (added by the first click of double-click)
    if (drawingPoints.length > 3) {
      drawingPoints.pop();
    }
    finishPolygon();
  }
});

overlay.addEventListener('mousemove', (e) => {
  const p = toImageCoords(e);
  mousePos = p;
  coordsEl.textContent = `${p.x}, ${p.y}`;

  if (dragging && selectedIdx >= 0 && dragVertexIdx >= 0) {
    regions[selectedIdx].polygon[dragVertexIdx] = [p.x, p.y];
    redraw();
    updatePropsFromRegion();
    return;
  }

  // Update cursor
  if (isDrawing()) {
    overlay.style.cursor = 'crosshair';
  } else if (selectedIdx >= 0) {
    const poly = regions[selectedIdx].polygon;
    let cursor = 'crosshair';
    // Check vertex hover
    for (let i = 0; i < poly.length; i++) {
      if (distPt(p.x, p.y, poly[i][0], poly[i][1]) < VERTEX_RADIUS * 2) {
        cursor = 'grab';
        break;
      }
    }
    // Check edge hover
    if (cursor === 'crosshair') {
      for (let i = 0; i < poly.length; i++) {
        const j = (i + 1) % poly.length;
        if (distToSegment(p.x, p.y, poly[i][0], poly[i][1], poly[j][0], poly[j][1]) < EDGE_INSERT_THRESHOLD) {
          cursor = 'cell';
          break;
        }
      }
    }
    // Check inside any polygon
    if (cursor === 'crosshair') {
      for (let i = regions.length - 1; i >= 0; i--) {
        const rp = regions[i].polygon;
        if (rp && rp.length >= 3 && pointInPolygon(p.x, p.y, rp)) {
          cursor = 'pointer';
          break;
        }
      }
    }
    overlay.style.cursor = cursor;
  } else {
    let cursor = 'crosshair';
    for (let i = regions.length - 1; i >= 0; i--) {
      const rp = regions[i].polygon;
      if (rp && rp.length >= 3 && pointInPolygon(p.x, p.y, rp)) {
        cursor = 'pointer';
        break;
      }
    }
    overlay.style.cursor = cursor;
  }

  redraw();
});

overlay.addEventListener('mouseup', (e) => {
  if (dragging) {
    dragging = false;
    dragVertexIdx = -1;
    renderRegionList();
  }
});

overlay.addEventListener('contextmenu', (e) => e.preventDefault());

function finishPolygon() {
  if (drawingPoints.length < 3) { drawingPoints = []; redraw(); return; }

  const idx = regions.length;
  const poly = drawingPoints.map(p => [Math.round(p[0]), Math.round(p[1])]);
  const centroidY = poly.reduce((s, p) => s + p[1], 0) / poly.length;

  regions.push({
    id: `region_${idx}`,
    type: 'baked_prop',
    polygon: poly,
    action: '',
    hover_style: 'glow',
    cursor: 'pointer',
    tooltip: '',
    layer: centroidY < imgH * 0.5 ? 'wall' : 'desk',
    disabled: false,
    color: COLORS[idx % COLORS.length]
  });

  drawingPoints = [];
  undoStack = [];
  selectRegion(idx);
  renderRegionList();
  redraw();

  propId.focus();
  propId.select();
}

// ── Zoom ──
canvasArea.addEventListener('wheel', (e) => {
  e.preventDefault();
  const delta = e.deltaY > 0 ? -0.1 : 0.1;
  zoom = Math.max(0.1, Math.min(3, zoom + delta));
  applyZoom();
}, { passive: false });

document.getElementById('btn-zoom-in').addEventListener('click', () => {
  zoom = Math.min(3, zoom + 0.2);
  applyZoom();
});
document.getElementById('btn-zoom-out').addEventListener('click', () => {
  zoom = Math.max(0.1, zoom - 0.2);
  applyZoom();
});
document.getElementById('btn-zoom-fit').addEventListener('click', fitZoom);

// ── Region list ──
function renderRegionList() {
  regionList.innerHTML = '';
  regions.forEach((r, i) => {
    const div = document.createElement('div');
    div.className = 'region-item' + (i === selectedIdx ? ' selected' : '');
    const bounds = computeBounds(r.polygon);
    div.innerHTML = `
      <span class="color-swatch" style="background:${r.color || COLORS[i % COLORS.length]}"></span>
      <span class="region-id">${r.id}</span>
      <span class="region-info">${r.polygon ? r.polygon.length + 'v' : '?'} ${bounds.width}x${bounds.height}</span>
      <button class="delete-btn" data-idx="${i}" title="Delete">&times;</button>
    `;
    div.addEventListener('click', (e) => {
      if (e.target.classList.contains('delete-btn')) return;
      selectRegion(i);
    });
    div.querySelector('.delete-btn').addEventListener('click', (e) => {
      e.stopPropagation();
      deleteRegion(i);
    });
    regionList.appendChild(div);
  });
}

function selectRegion(idx) {
  selectedIdx = idx;
  drawingPoints = [];
  renderRegionList();
  if (idx >= 0) {
    propsPanel.classList.remove('hidden');
    updatePropsFromRegion();
  } else {
    propsPanel.classList.add('hidden');
  }
  redraw();
}

function deleteRegion(idx) {
  regions.splice(idx, 1);
  if (selectedIdx === idx) selectedIdx = -1;
  else if (selectedIdx > idx) selectedIdx--;
  renderRegionList();
  redraw();
}

function updatePropsFromRegion() {
  if (selectedIdx < 0) return;
  const r = regions[selectedIdx];
  const bounds = computeBounds(r.polygon);
  propId.value = r.id;
  propType.value = r.type;
  propX.value = bounds.x;
  propY.value = bounds.y;
  propW.value = bounds.width;
  propH.value = bounds.height;
  propVertexCount.textContent = `${r.polygon ? r.polygon.length : 0} vertices`;
  propAction.value = r.action;
  propHover.value = r.hover_style;
  propCursor.value = r.cursor;
  propTooltip.value = r.tooltip;
  propLayer.value = r.layer;
  propDisabled.checked = r.disabled;
}

function updateRegionFromProps() {
  if (selectedIdx < 0) return;
  const r = regions[selectedIdx];
  r.id = propId.value.trim() || r.id;
  r.type = propType.value;
  r.action = propAction.value.trim();
  r.hover_style = propHover.value;
  r.cursor = propCursor.value;
  r.tooltip = propTooltip.value.trim();
  r.layer = propLayer.value;
  r.disabled = propDisabled.checked;
  renderRegionList();
  redraw();
}

[propId, propType, propAction, propHover, propCursor, propTooltip, propLayer].forEach(el => {
  el.addEventListener('input', updateRegionFromProps);
  el.addEventListener('change', updateRegionFromProps);
});
propDisabled.addEventListener('change', updateRegionFromProps);

// ── Keyboard ──
document.addEventListener('keydown', (e) => {
  // Don't intercept when typing in inputs
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') {
    if (e.key === 'Escape') { e.target.blur(); selectRegion(-1); }
    return;
  }

  if (e.key === 'Escape') {
    if (isDrawing()) {
      drawingPoints = [];
      undoStack = [];
      redraw();
    } else {
      selectRegion(-1);
    }
  }

  if (e.key === 'Enter') {
    if (drawingPoints.length >= 3) {
      finishPolygon();
    }
  }

  if ((e.key === 'Delete' || e.key === 'Backspace') && !isDrawing()) {
    if (selectedIdx >= 0) deleteRegion(selectedIdx);
  }

  if (e.key === 'z' && (e.ctrlKey || e.metaKey)) {
    e.preventDefault();
    if (isDrawing() && drawingPoints.length > 0) {
      drawingPoints.pop();
      redraw();
    } else if (undoStack.length > 0) {
      const action = undoStack.pop();
      if (action.type === 'move_vertex' && action.regionIdx < regions.length) {
        regions[action.regionIdx].polygon[action.vertexIdx] = action.oldPoint;
        redraw();
        updatePropsFromRegion();
      }
      if (action.type === 'delete_vertex' && action.regionIdx < regions.length) {
        regions[action.regionIdx].polygon.splice(action.vertexIdx, 0, action.point);
        redraw();
        updatePropsFromRegion();
      }
      if (action.type === 'insert_vertex' && action.regionIdx < regions.length) {
        regions[action.regionIdx].polygon.splice(action.vertexIdx, 1);
        redraw();
        updatePropsFromRegion();
      }
    }
  }
});

// ── Export ──
function buildJSON() {
  return {
    schema_version: "2.0",
    image_dimensions: { width: imgW, height: imgH },
    regions: regions.map(r => {
      const bounds = computeBounds(r.polygon);
      const out = {
        id: r.id,
        type: r.type,
        bounds: bounds,
        polygon: r.polygon.map(p => [Math.round(p[0]), Math.round(p[1])]),
        action: r.action,
        hover_style: r.hover_style,
        cursor: r.cursor,
        tooltip: r.tooltip,
        layer: r.layer
      };
      if (r.disabled) out.disabled = true;
      return out;
    })
  };
}

document.getElementById('btn-export').addEventListener('click', () => {
  const json = JSON.stringify(buildJSON(), null, 2);
  const blob = new Blob([json + '\n'], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'hq_clickable_regions.json';
  a.click();
  URL.revokeObjectURL(url);
});

document.getElementById('btn-copy').addEventListener('click', () => {
  const json = JSON.stringify(buildJSON(), null, 2);
  navigator.clipboard.writeText(json).then(() => {
    const btn = document.getElementById('btn-copy');
    btn.textContent = 'Copied!';
    setTimeout(() => { btn.textContent = 'Copy JSON'; }, 1500);
  });
});

document.getElementById('btn-clear-all').addEventListener('click', () => {
  if (!confirm('Delete all regions?')) return;
  regions = [];
  selectedIdx = -1;
  drawingPoints = [];
  renderRegionList();
  redraw();
  propsPanel.classList.add('hidden');
});

// ── Init ──
resizeCanvases();
drawBg();
fitZoom();
</script>
</body>
</html>
